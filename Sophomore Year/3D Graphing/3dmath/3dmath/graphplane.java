import static java.lang.System.*;import java.awt.*;import static java.awt.Color.*;import java.awt.event.*;import java.awt.event.KeyEvent.*;import java.awt.Event.*;import java.awt.image.*;import java.applet.*;import java.io.*;import java.net.*;import java.text.*;import javax.swing.*;import java.lang.*;import java.util.*;import java.sql.*;import sun.audio.*;public class graphplane extends graph{	int faster;    Matrix objects;    double minx;    double maxx;    double miny;    double maxy;    String s1;    String s2;    int xyz;    public graphplane()    {        faster = 0;        objects = new Matrix();        minx = 0.0D;        maxx = 0.0D;        miny = 0.0D;        maxy = 0.0D;        xyz = -1;    }    public void add(Extendable extendable)    {        Pointsrectolinier pointsrectolinier = (Pointsrectolinier)extendable;        objects.add(pointsrectolinier);    }    public void init(Tree tree, String s, Tree tree1, String s3, Tree tree2, String s4, double d, double d1)    {        minx = miny = -d;        maxx = maxy = d;        System.out.println("INITINIT/n/n/n/nINITINIT");        x = tree;        y = tree1;        z = tree2;        xs = s;        ys = s3;        zs = s4;        int i = 0;        boolean flag = false;        double d2 = d;        double d3 = d1;        for(double d4 = -d; d4 <= d; d4 += d1)        {            System.out.println((new StringBuilder()).append("row").append(i).toString());            int j = 0;            for(double d5 = -d2; d5 <= d2; d5 += d3)            {                Pointsrectolinier pointsrectolinier = new Pointsrectolinier(d5, d4);                if(tree != null)                {                    xyz = 0;                    tree.set(s1 = s3, d4);                    tree.set(s2 = s4, d5);                    pointsrectolinier.setTo(tree.getnum(), d4, d5);                } else                if(tree1 != null)                {                    xyz = 1;                    tree1.set(s2 = s4, d5);                    tree1.set(s1 = s, d4);                    pointsrectolinier.setTo(d4, tree1.getnum(), d5);                } else                if(tree2 != null)                {                    xyz = 2;                    tree2.set(s2 = s3, d5);                    tree2.set(s1 = s, d4);                    pointsrectolinier.setTo(d4, d5, tree2.getnum());                }                objects.add(pointsrectolinier);                j++;            }            i++;        }        transforms.add(new Trans(0, panz));        current = 0;    }    public void panupdown(boolean flag)    {        if(flag)            variables.pany++;        else            variables.pany--;    }    public void panleftright(boolean flag)    {        if(flag)            panx++;        else            panx--;    }    public void Moveupdown(boolean flag)    {        double d = variables.finald - variables.panz;        if(panz <= -9D || panz > 0.0D)        {            if(d >= 0.0D)            {                d = Math.log(Math.abs(d) + 1.0D) * 5D + 1.0D;            } else            {                d = Math.abs(d);                if(d < 1.0D)                    d = 1.0D;                d = 1.0D / Math.log(d / 2D + 1.0D);            }        } else        {            double d1 = finald - panz;            d1 = Math.pow(panz / 10D, (int)Math.abs(d1)) + Math.abs(panz) / 100D;            d = d1;        }        if(flag)            variables.pany0 += d;        else            variables.pany0 -= d;        int i = 1;        if(current != Math.abs(i))        {            if(flag)                current = -i;            else                current = i;            transforms.add(new Trans(current, variables.pany0));        } else        if(current != i)        {            current = -i;            transforms.add(new Trans(current, variables.pany0));        } else        if(current != -i)        {            current = i;            transforms.add(new Trans(current, variables.pany0));        } else        {            transforms.get(transforms.size() - 1).setTo(variables.pany0);        }        for(int j = 0; j < objects.size(); j++)            objects.get(j).recalculate();    }    public void Moveleftright(boolean flag)    {        double d = variables.finald - variables.panz;        if(panz <= -9D || panz > 0.0D)        {            if(d >= 0.0D)            {                d = Math.log(Math.abs(d) + 1.0D) * 5D + 1.0D;            } else            {                d = Math.abs(d);                if(d < 1.0D)                    d = 1.0D;                d = 1.0D / Math.log(d / 2D + 1.0D);            }        } else        {            double d1 = finald - panz;            d1 = Math.pow(panz / 10D, (int)Math.abs(d1)) + Math.abs(panz) / 100D;            d = d1;        }        if(flag)            variables.panx0 += d;        else            variables.panx0 -= d;        int i = 2;        if(current != Math.abs(i))        {            if(flag)                current = -i;            else                current = i;            transforms.add(new Trans(current, variables.panx0));        } else        if(current != i)        {            current = -i;            transforms.add(new Trans(current, variables.panx0));        } else        if(current != -i)        {            current = i;            transforms.add(new Trans(current, variables.panx0));        } else        {            transforms.get(transforms.size() - 1).setTo(variables.panx0);        }        for(int j = 0; j < objects.size(); j++)            objects.get(j).recalculate();    }    public void zoomIn()    {        super.zoomIn();        int i = 0;        if(current != i)        {            current = i;            transforms.add(new Trans(current, panz));        } else        {            transforms.get(transforms.size() - 1).setTo(panz);        }    }    public void zoomOut()    {        super.zoomOut();        int i = 0;        if(current != i)        {            current = i;            transforms.add(new Trans(current, panz));        } else        {            transforms.get(transforms.size() - 1).setTo(panz);        }    }    public void goback()    {        current = -6;        transforms = new ArrayList<Trans>();        transforms.add(new Trans(0, panz));        panx = fpanx;        pany = fpany;        panz = fpanz;        panx0 = 0.0D;        pany0 = 0.0D;        for(int i = 0; i < objects.size(); i++)            objects.get(i).goback();    }    public void rotatey()    {        int i = 3;        if(current != i)        {            current = i;            Trans trans = new Trans(current, 1.0D);            trans.to = form;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int j = 0; j < objects.size(); j++)            objects.get(j).rotateY(form);        if(second || tempsecond)            origin.rotateY(form);    }    public void rotatex()    {        int i = 4;        if(current != i)        {            current = i;            Trans trans = new Trans(current, 1.0D);            trans.to = form;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int j = 0; j < objects.size(); j++)            objects.get(j).rotateX(form);        if(second || tempsecond)            origin.rotateX(form);    }    public void rotatez()    {        int i = 5;        if(current != i)        {            current = i;            Trans trans = new Trans(current, 1.0D);            trans.to = form;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int j = 0; j < objects.size(); j++)            objects.get(j).rotateZ(form);        if(second || tempsecond)            origin.rotateZ(form);    }    public void backrotatey()    {        int i = -3;        if(current != i)        {            current = i;            Trans trans = new Trans(current, 1.0D);            trans.to = form2;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int j = 0; j < objects.size(); j++)            objects.get(j).rotateY(form2);        if(second || tempsecond)            origin.rotateY(form2);    }    public void backrotatex()    {        int i = -4;        if(current != i)        {            current = i;            Trans trans = new Trans(current, 1.0D);            trans.to = form2;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int j = 0; j < objects.size(); j++)            objects.get(j).rotateX(form2);        if(second || tempsecond)            origin.rotateX(form2);    }    public void backrotatez()    {        int i = -5;        if(current != i)        {            current = i;            Trans trans = new Trans(current, 1.0D);            trans.to = form2;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int j = 0; j < objects.size(); j++)            objects.get(j).rotateZ(form2);        if(second || tempsecond)            origin.rotateZ(form2);    }    public void Moveupdown(boolean flag, int i)    {        double d = variables.finald - variables.panz;        if(panz <= -9D || panz > 0.0D)        {            if(d >= 0.0D)            {                d = Math.log(Math.abs(d) + 1.0D) * 5D + 1.0D;            } else            {                d = Math.abs(d);                if(d < 1.0D)                    d = 1.0D;                d = 1.0D / Math.log(d / 2D + 1.0D);            }        } else        {            double d1 = finald - panz;            d1 = Math.pow(panz / 10D, (int)Math.abs(d1)) + Math.abs(panz) / 100D;            d = d1;        }        if(flag)            variables.pany0 += d;        else            variables.pany0 -= d;        int j = 1;        if(current != Math.abs(j))        {            if(flag)                current = -j;            else                current = j;            transforms.add(new Trans(current, variables.pany0));        } else        if(current != j)        {            current = -j;            transforms.add(new Trans(current, variables.pany0));        } else        if(current != -j)        {            current = j;            transforms.add(new Trans(current, variables.pany0));        } else        {            transforms.get(transforms.size() - 1).setTo(variables.pany0);        }    }    public void Moveleftright(boolean flag, int i)    {        double d = variables.finald - variables.panz;        if(panz <= -9D || panz > 0.0D)        {            if(d >= 0.0D)            {                d = Math.log(Math.abs(d) + 1.0D) * 5D + 1.0D;            } else            {                d = Math.abs(d);                if(d < 1.0D)                    d = 1.0D;                d = 1.0D / Math.log(d / 2D + 1.0D);            }        } else        {            double d1 = finald - panz;            d1 = Math.pow(panz / 10D, (int)Math.abs(d1)) + Math.abs(panz) / 100D;            d = d1;        }        if(flag)            variables.panx0 += d;        else            variables.panx0 -= d;        int j = 2;        if(current != Math.abs(j))        {            if(flag)                current = -j;            else                current = j;            transforms.add(new Trans(current, variables.panx0));        } else        if(current != j)        {            current = -j;            transforms.add(new Trans(current, variables.panx0));        } else        if(current != -j)        {            current = j;            transforms.add(new Trans(current, variables.panx0));        } else        {            transforms.get(transforms.size() - 1).setTo(variables.panx0);        }    }    public void zoomIn(int i)    {        if(panz <= -9D || panz > 0.0D)        {            double d = finald - panz;            d = Math.pow(0.99999899999999997D, (d * d) / 5D) - 0.10000000000000001D;            panz += d;        } else        {            double d1 = finald - panz;            d1 = Math.pow(panz / 10D, (int)Math.abs(d1)) + Math.abs(panz) / 100D;            panz += Math.abs(d1);        }        int j = 0;        if(current != j)        {            current = j;            transforms.add(new Trans(current, panz));        } else        {            transforms.get(transforms.size() - 1).setTo(panz);        }    }    public void zoomOut(int i)    {        double d = finald - panz;        d = Math.pow(0.99999899999999997D, (d * d) / 5D) - 0.10000000000000001D;        panz -= d;        int j = 0;        if(current != j)        {            current = j;            transforms.add(new Trans(current, panz));        } else        {            transforms.get(transforms.size() - 1).setTo(panz);        }    }    public void goback(int i)    {        transforms = new ArrayList<Trans>();        current = -6;        current = 0;        panx = fpanx;        pany = fpany;        panz = fpanz;        transforms.add(new Trans(current, panz));        panx0 = 0.0D;        pany0 = 0.0D;        for(int j = 0; j < objects.size(); j++)            objects.get(j).goback();        if(second || tempsecond)        {            for(int k = 0; k < axis.size(); k++)                axis.get(k).goback();        }        if(second || tempsecond)            origin.goback();        recalculate();    }    public void rotatey(int i)    {        int j = 3;        if(current != j)        {            current = j;            Trans trans = new Trans(current, 1.0D);            trans.to = form;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int k = 0; k < objects.size(); k++)            objects.get(k).rotateY(form);        if(second || tempsecond)        {            for(int l = 0; l < axis.size(); l++)                axis.get(l).rotateY(form);        }        if(second || tempsecond)            origin.rotateY(form);    }    public void rotatex(int i)    {        int j = 4;        if(current != j)        {            current = j;            Trans trans = new Trans(current, 1.0D);            trans.to = form;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int k = 0; k < objects.size(); k++)            objects.get(k).rotateX(form);        if(second || tempsecond)        {            for(int l = 0; l < axis.size(); l++)                axis.get(l).rotateX(form);        }        if(second || tempsecond)            origin.rotateX(form);    }    public void rotatez(int i)    {        int j = 5;        if(current != j)        {            current = j;            Trans trans = new Trans(current, 1.0D);            trans.to = form;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int k = 0; k < objects.size(); k++)            objects.get(k).rotateZ(form);        if(second || tempsecond)        {            for(int l = 0; l < axis.size(); l++)                axis.get(l).rotateZ(form);        }        if(second || tempsecond)            origin.rotateZ(form);    }    public void backrotatey(int i)    {        int j = -3;        if(current != j)        {            current = j;            Trans trans = new Trans(current, 1.0D);            trans.to = form2;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int k = 0; k < objects.size(); k++)            objects.get(k).rotateY(form2);        if(second || tempsecond)        {            for(int l = 0; l < axis.size(); l++)                axis.get(l).rotateY(form2);        }        if(second || tempsecond)            origin.rotateY(form2);    }    public void backrotatex(int i)    {        int j = -4;        if(current != j)        {            current = j;            Trans trans = new Trans(current, 1.0D);            trans.to = form2;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int k = 0; k < objects.size(); k++)            objects.get(k).rotateX(form2);        if(second || tempsecond)        {            for(int l = 0; l < axis.size(); l++)                axis.get(l).rotateX(form2);        }        if(second || tempsecond)            origin.rotateX(form2);    }    public void backrotatez(int i)    {        int j = -5;        if(current != j)        {            current = j;            Trans trans = new Trans(current, 1.0D);            trans.to = form2;            transforms.add(trans);        } else        {            transforms.get(transforms.size() - 1).add();        }        for(int k = 0; k < objects.size(); k++)            objects.get(k).rotateZ(form2);        if(second || tempsecond)        {            for(int l = 0; l < axis.size(); l++)                axis.get(l).rotateZ(form2);        }        if(second || tempsecond)            origin.rotateZ(form2);    }    public void recalc2()    {        if(objects.length() > 1)        {            double d = Points.visualDistance(objects.get(0), objects.get(1));            if(d > Pointsrectolinier.getD4())            {                int k = 0;                for(int j1 = 0; j1 < objects.nlength(); j1++)                {                    int l1 = 0;                    double d1 = objects.getY(j1);                    if(k % 2 == 1 && j1 > 0)                        d1 = (objects.getY(j1 - 1) + d1) / 2D;                    for(int j2 = 0; j2 < objects.length(j1); j2++)                    {                        if(l1 % 2 == 1 && j2 > 0)                        {                            double d3;                            if(k % 2 == 1 && j1 > 0)                                d3 = (objects.getX((j2 - 1) * 2, j1 - 1) + objects.getX(j2 * 2, j1 - 1)) / 2D;                            else                                d3 = (objects.getX(j2 - 1, j1) + objects.getX(j2, j1)) / 2D;                            Pointsrectolinier pointsrectolinier = new Pointsrectolinier(d3, d1);                            set(d3, d1);                            pointsrectolinier.setTo(getxn(d3, d1), getyn(d3, d1), getzn(d3, d1));                            pointsrectolinier.recalculate(transforms);                            objects.add(pointsrectolinier);                        }                        l1++;                    }                    k++;                }            } else            if(d < Pointsrectolinier.getD3())            {                int l = 0;                for(int k1 = 0; k1 < objects.nlength() - 1; k1++)                {                    int i2 = 0;                    double d2 = objects.getY(k1);                    if(l % 2 == 1 && k1 > 0)                    {                        objects.removelist(k1);                        k1--;                        l++;                    }                    ArrayList arraylist = objects.getlist(k1);                    for(int k2 = 0; k2 < arraylist.size() - 1; k2++)                    {                        if(i2 % 2 == 1 && k2 > 0)                        {                            arraylist.remove(k2);                            k2--;                            i2++;                        }                        i2++;                    }                    l++;                }            } else            {                for(int i1 = 0; i1 < objects.size(); i1++)                    objects.get(i1).recalculate();            }        } else        {            for(int i = 0; i < objects.size(); i++)                objects.get(i).recalculate();        }        for(int j = 0; j < axis.size(); j++)            axis.get(j).recalculate();        origin.recalculate();    }    public void recalc()    {        for(int i = 0; i < objects.size(); i++)            objects.get(i).recalculate();    }    public void recalculate()    {        if(faster < 10 || faster > 10 && faster < 20)        {            recalc();            faster++;        } else        if(faster == 10)            faster++;        else        if(faster == 20)            faster = 0;        for(int i = 0; i < axis.size(); i++)            axis.get(i).recalculate();        origin.recalculate();    }    private void recalc3()    {        int i = 0;        i = objects.size();        boolean flag = false;        for(int j = 0; j < objects.nlength() - 1; j++)        {            ArrayList arraylist2 = objects.getlist(j);            if(arraylist2.size() == 1)            {                Pointsrectolinier pointsrectolinier = (Pointsrectolinier)arraylist2.get(0);                pointsrectolinier.recalculate();                Pointsrectolinier pointsrectolinier1 = objects.get(pointsrectolinier.graphx, objects.getY(j + 1));                if(pointsrectolinier1 == null)                    continue;                pointsrectolinier1.recalculate();                double d = Points.visualDistance(pointsrectolinier, pointsrectolinier1);                if(d > Pointsrectolinier.getD4() && pointsrectolinier1.onscreen && pointsrectolinier.onscreen)                {                    addlist(pointsrectolinier, pointsrectolinier1);                    continue;                }                if(d < Pointsrectolinier.getD3())                    objects.remove(pointsrectolinier1);                continue;            }            for(int j1 = 0; j1 < arraylist2.size() - 1; j1++)            {                Pointsrectolinier pointsrectolinier2 = (Pointsrectolinier)arraylist2.get(j1);                pointsrectolinier2.recalculate();                Pointsrectolinier pointsrectolinier3;                if(!flag)                    pointsrectolinier3 = objects.get(pointsrectolinier2.graphx, objects.getY(j + 1));                else                    pointsrectolinier3 = objects.get(pointsrectolinier2.graphx, objects.getY(j + 2));                Pointsrectolinier pointsrectolinier4 = (Pointsrectolinier)arraylist2.get(j1 + 1);                if(pointsrectolinier3 != null)                {                    pointsrectolinier3.recalculate();                    double d1 = Points.visualDistance(pointsrectolinier2, pointsrectolinier3);                    if(d1 > Pointsrectolinier.getD4() && pointsrectolinier3.onscreen && pointsrectolinier2.onscreen)                    {                        if(addlist(pointsrectolinier2, pointsrectolinier3))                            flag = true;                    } else                    if(d1 < Pointsrectolinier.getD3())                        objects.remove(pointsrectolinier3);                }                if(pointsrectolinier4 == null)                    continue;                pointsrectolinier4.recalculate();                double d2 = Points.visualDistance(pointsrectolinier2, pointsrectolinier4);                if(d2 > Pointsrectolinier.getD4() && pointsrectolinier4.onscreen && pointsrectolinier2.onscreen)                {                    addpoint(arraylist2, pointsrectolinier2, pointsrectolinier4);                    continue;                }                if(d2 < Pointsrectolinier.getD3())                {                    objects.remove(pointsrectolinier4);                    j1--;                }            }        }        ArrayList arraylist = objects.getlist(objects.nlength() - 1);        for(int k = 0; k < arraylist.size(); k++)            ((Pointsrectolinier)arraylist.get(k)).recalculate();        for(int l = 0; l < objects.nlength(); l++)        {            ArrayList arraylist1 = objects.getlist(l);            ((Pointsrectolinier)arraylist1.get(arraylist1.size() - 1)).recalculate();        }        int i1 = objects.length();        int k1 = objects.resetSize();    }    public boolean addlist(Pointsrectolinier pointsrectolinier, Pointsrectolinier pointsrectolinier1)    {        boolean flag = false;        double d = (pointsrectolinier.graphy + pointsrectolinier1.graphy) / 2D;        StringBuffer stringbuffer = new StringBuffer("10");        ArrayList<Pointsrectolinier> arraylist = objects.get2(d, 0, objects.nlength(), stringbuffer);        if(stringbuffer.equals(new StringBuffer("01")))            flag = true;        Pointsrectolinier pointsrectolinier2 = new Pointsrectolinier(pointsrectolinier.graphx, d);        set(pointsrectolinier.graphx, d);        pointsrectolinier2.setTo(getxn(pointsrectolinier.graphx, d), getyn(pointsrectolinier.graphx, d), getzn(pointsrectolinier.graphx, d));        pointsrectolinier2.recalculate(transforms);        if(pointsrectolinier2.onscreen)            objects.add(pointsrectolinier2, arraylist, pointsrectolinier.graphx);        return flag;    }    public void addpoint(ArrayList arraylist, Pointsrectolinier pointsrectolinier, Pointsrectolinier pointsrectolinier1)    {        double d = (pointsrectolinier.graphx + pointsrectolinier1.graphx) / 2D;        Pointsrectolinier pointsrectolinier2 = new Pointsrectolinier(d, pointsrectolinier.graphy);        set(d, pointsrectolinier.graphy);        pointsrectolinier2.setTo(getxn(d, pointsrectolinier.graphy), getyn(d, pointsrectolinier.graphy), getzn(d, pointsrectolinier.graphy));        pointsrectolinier2.recalculate(transforms);        if(pointsrectolinier2.onscreen)            objects.add(pointsrectolinier2);    }    public void setColor(Color color)    {        clor = color;        for(int i = 0; i < objects.size(); i++)            objects.get(i).setColor(color);    }    public void drawgraph(Graphics2D graphics2d)    {        if(oldxcamera != xcamera || oldpanx != panx || oldycamera != ycamera || oldpany != pany || oldzcamera != zcamera || oldpany != pany || oldd != distance)        {            oldxcamera = xcamera;            oldpanx = panx;            oldycamera = ycamera;            oldpany = pany;            oldzcamera = zcamera;            oldpany = pany;            oldd = distance;            for(int i = 0; i < objects.size(); i++)                objects.get(i).recalculate();            if(second || tempsecond)            {                for(int j = 0; j < axis.size(); j++)                    axis.get(j).recalculate();            }        }        for(int k = 0; k < objects.size(); k++)            try            {                Pointsrectolinier pointsrectolinier = objects.get(k);                if(pointsrectolinier.z + panz <= 0.0D)                    pointsrectolinier.draw(graphics2d);            }            catch(Exception exception) { }    }    public void set(double d, double d1)    {        switch(xyz)        {        case 0: // '\0'            x.set(s1, d);            x.set(s2, d1);            return;        case 1: // '\001'            y.set(s1, d);            y.set(s2, d1);            return;        case 2: // '\002'            z.set(s1, d);            z.set(s2, d1);            return;        }    }    private double getxn(double d, double d1)    {        switch(xyz)        {        case 0: // '\0'            return x.getnum();        case 1: // '\001'            return d;        case 2: // '\002'            return d1;        }        return (1.0D / 0.0D);    }    private double getyn(double d, double d1)    {        switch(xyz)        {        case 0: // '\0'            return d;        case 1: // '\001'            return y.getnum();        case 2: // '\002'            return d1;        }        return (1.0D / 0.0D);    }    private double getzn(double d, double d1)    {        switch(xyz)        {        case 0: // '\0'            return d;        case 1: // '\001'            return d1;        case 2: // '\002'            return z.getnum();        }        return (1.0D / 0.0D);    }    public Tree getTree()    {        switch(xyz)        {        case 0: // '\0'            return x;        case 1: // '\001'            return y;        case 2: // '\002'            return z;        }        return null;    }    public String getSolve()    {        switch(xyz)        {        case 0: // '\0'            return "x";        case 1: // '\001'            return "y";        case 2: // '\002'            return "z";        }        return null;    }    public String printTree(threedpicmaker t2)	{				String x2="the equation for the "+ getSolve()+" cordinate is:\n"+getTree().toString2();		return x2;	}}